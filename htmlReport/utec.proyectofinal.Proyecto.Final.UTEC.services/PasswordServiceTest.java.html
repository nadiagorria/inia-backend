<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PasswordServiceTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">java in Proyecto-Final-UTEC Coverage Results</a> &gt; <a href="index.source.html" class="el_package">utec.proyectofinal.Proyecto.Final.UTEC.services</a> &gt; <span class="el_source">PasswordServiceTest.java</span></div><h1>PasswordServiceTest.java</h1><pre class="source lang-java linenums">package utec.proyectofinal.Proyecto.Final.UTEC.services;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;


@ExtendWith(MockitoExtension.class)
@DisplayName(&quot;Tests de PasswordService (Seguridad)&quot;)
<span class="fc" id="L14">class PasswordServiceTest {</span>

    private PasswordService passwordService;

    @BeforeEach
    void setUp() {
<span class="fc" id="L20">        passwordService = new PasswordService();</span>
<span class="fc" id="L21">    }</span>

    @Test
    @DisplayName(&quot;Encriptar contraseña - debe retornar hash BCrypt válido&quot;)
    void encryptPassword_debeRetornarHashBCrypt() {
        
<span class="fc" id="L27">        String plainPassword = &quot;MiContraseña123!&quot;;</span>

        
<span class="fc" id="L30">        String encryptedPassword = passwordService.encryptPassword(plainPassword);</span>

        
<span class="fc" id="L33">        assertNotNull(encryptedPassword, &quot;El hash no debe ser nulo&quot;);</span>
<span class="fc" id="L34">        assertNotEquals(plainPassword, encryptedPassword, &quot;El hash debe ser diferente a la contraseña original&quot;);</span>
<span class="pc bpc" id="L35" title="3 of 4 branches missed.">        assertTrue(encryptedPassword.startsWith(&quot;$2a$&quot;) || encryptedPassword.startsWith(&quot;$2b$&quot;), </span>
            &quot;Debe ser un hash BCrypt válido&quot;);
<span class="pc bpc" id="L37" title="1 of 2 branches missed.">        assertTrue(encryptedPassword.length() &gt; 50, &quot;El hash BCrypt debe tener longitud apropiada&quot;);</span>
<span class="fc" id="L38">    }</span>

    @Test
    @DisplayName(&quot;Encriptar misma contraseña dos veces - debe generar hashes diferentes&quot;)
    void encryptPassword_mismaContraseña_debeGenerarHashesDiferentes() {
        
<span class="fc" id="L44">        String plainPassword = &quot;Password123!&quot;;</span>

        
<span class="fc" id="L47">        String hash1 = passwordService.encryptPassword(plainPassword);</span>
<span class="fc" id="L48">        String hash2 = passwordService.encryptPassword(plainPassword);</span>

        
<span class="fc" id="L51">        assertNotEquals(hash1, hash2, </span>
            &quot;BCrypt debe generar hashes diferentes para la misma contraseña (salt aleatorio)&quot;);
<span class="fc" id="L53">    }</span>

    @Test
    @DisplayName(&quot;Verificar contraseña correcta - debe retornar true&quot;)
    void matchPassword_contraseñaCorrecta_debeRetornarTrue() {
        
<span class="fc" id="L59">        String plainPassword = &quot;SecurePass456!&quot;;</span>
<span class="fc" id="L60">        String encryptedPassword = passwordService.encryptPassword(plainPassword);</span>

        
<span class="fc" id="L63">        boolean matches = passwordService.matchPassword(plainPassword, encryptedPassword);</span>

        
<span class="fc" id="L66">        assertTrue(matches, &quot;La contraseña correcta debe ser verificada exitosamente&quot;);</span>
<span class="fc" id="L67">    }</span>

    @Test
    @DisplayName(&quot;Verificar contraseña incorrecta - debe retornar false&quot;)
    void matchPassword_contraseñaIncorrecta_debeRetornarFalse() {
        
<span class="fc" id="L73">        String plainPassword = &quot;CorrectPassword123!&quot;;</span>
<span class="fc" id="L74">        String wrongPassword = &quot;WrongPassword456!&quot;;</span>
<span class="fc" id="L75">        String encryptedPassword = passwordService.encryptPassword(plainPassword);</span>

        
<span class="fc" id="L78">        boolean matches = passwordService.matchPassword(wrongPassword, encryptedPassword);</span>

        
<span class="fc" id="L81">        assertFalse(matches, &quot;Una contraseña incorrecta debe fallar la verificación&quot;);</span>
<span class="fc" id="L82">    }</span>

    @Test
    @DisplayName(&quot;Verificar contraseña con mayúsculas/minúsculas - debe ser case sensitive&quot;)
    void matchPassword_caseSensitive_debeFallar() {
        
<span class="fc" id="L88">        String plainPassword = &quot;Password123&quot;;</span>
<span class="fc" id="L89">        String wrongCasePassword = &quot;password123&quot;;</span>
<span class="fc" id="L90">        String encryptedPassword = passwordService.encryptPassword(plainPassword);</span>

        
<span class="fc" id="L93">        boolean matches = passwordService.matchPassword(wrongCasePassword, encryptedPassword);</span>

        
<span class="fc" id="L96">        assertFalse(matches, &quot;La verificación debe ser case-sensitive&quot;);</span>
<span class="fc" id="L97">    }</span>

    @Test
    @DisplayName(&quot;Encriptar contraseña con caracteres especiales - debe funcionar correctamente&quot;)
    void encryptPassword_conCaracteresEspeciales_debeFuncionar() {
        
<span class="fc" id="L103">        String specialPassword = &quot;P@ssw0rd!#$%&amp;*()&quot;;</span>

        
<span class="fc" id="L106">        String encrypted = passwordService.encryptPassword(specialPassword);</span>
<span class="fc" id="L107">        boolean matches = passwordService.matchPassword(specialPassword, encrypted);</span>

        
<span class="fc" id="L110">        assertNotNull(encrypted);</span>
<span class="fc" id="L111">        assertTrue(matches, &quot;Debe manejar caracteres especiales correctamente&quot;);</span>
<span class="fc" id="L112">    }</span>

    @Test
    @DisplayName(&quot;Encriptar contraseña con espacios - debe preservar espacios&quot;)
    void encryptPassword_conEspacios_debePreservarEspacios() {
        
<span class="fc" id="L118">        String passwordWithSpaces = &quot;My Pass Word 123&quot;;</span>

        
<span class="fc" id="L121">        String encrypted = passwordService.encryptPassword(passwordWithSpaces);</span>
<span class="fc" id="L122">        boolean matchesWithSpaces = passwordService.matchPassword(passwordWithSpaces, encrypted);</span>
<span class="fc" id="L123">        boolean matchesWithoutSpaces = passwordService.matchPassword(&quot;MyPassWord123&quot;, encrypted);</span>

        
<span class="fc" id="L126">        assertTrue(matchesWithSpaces, &quot;Debe preservar espacios en la contraseña&quot;);</span>
<span class="fc" id="L127">        assertFalse(matchesWithoutSpaces, &quot;No debe coincidir sin los espacios&quot;);</span>
<span class="fc" id="L128">    }</span>

    @Test
    @DisplayName(&quot;Encriptar contraseña muy larga - debe funcionar&quot;)
    void encryptPassword_contraseñaMuyLarga_debeFuncionar() {
        
        
<span class="fc" id="L135">        String longPassword = &quot;A&quot;.repeat(70);</span>

        
<span class="fc" id="L138">        String encrypted = passwordService.encryptPassword(longPassword);</span>
<span class="fc" id="L139">        boolean matches = passwordService.matchPassword(longPassword, encrypted);</span>

        
<span class="fc" id="L142">        assertNotNull(encrypted);</span>
<span class="fc" id="L143">        assertTrue(matches, &quot;Debe manejar contraseñas largas (hasta 72 bytes)&quot;);</span>
<span class="fc" id="L144">    }</span>

    @Test
    @DisplayName(&quot;Encriptar contraseña muy corta - debe funcionar&quot;)
    void encryptPassword_contraseñaMuyCorta_debeFuncionar() {
        
<span class="fc" id="L150">        String shortPassword = &quot;Ab1&quot;;</span>

        
<span class="fc" id="L153">        String encrypted = passwordService.encryptPassword(shortPassword);</span>
<span class="fc" id="L154">        boolean matches = passwordService.matchPassword(shortPassword, encrypted);</span>

        
<span class="fc" id="L157">        assertNotNull(encrypted);</span>
<span class="fc" id="L158">        assertTrue(matches, &quot;Debe manejar contraseñas cortas&quot;);</span>
<span class="fc" id="L159">    }</span>

    @Test
    @DisplayName(&quot;Verificar con contraseña vacía - debe retornar false&quot;)
    void matchPassword_contraseñaVacia_debeRetornarFalse() {
        
<span class="fc" id="L165">        String plainPassword = &quot;ValidPassword123&quot;;</span>
<span class="fc" id="L166">        String encryptedPassword = passwordService.encryptPassword(plainPassword);</span>

        
<span class="fc" id="L169">        boolean matches = passwordService.matchPassword(&quot;&quot;, encryptedPassword);</span>

        
<span class="fc" id="L172">        assertFalse(matches, &quot;Una contraseña vacía no debe coincidir&quot;);</span>
<span class="fc" id="L173">    }</span>

    @Test
    @DisplayName(&quot;Encriptar contraseña con Unicode - debe funcionar&quot;)
    void encryptPassword_conUnicode_debeFuncionar() {
        
<span class="fc" id="L179">        String unicodePassword = &quot;Contraseña123áéíóú&quot;;</span>

        
<span class="fc" id="L182">        String encrypted = passwordService.encryptPassword(unicodePassword);</span>
<span class="fc" id="L183">        boolean matches = passwordService.matchPassword(unicodePassword, encrypted);</span>

        
<span class="fc" id="L186">        assertNotNull(encrypted);</span>
<span class="fc" id="L187">        assertTrue(matches, &quot;Debe manejar caracteres Unicode correctamente&quot;);</span>
<span class="fc" id="L188">    }</span>

    @Test
    @DisplayName(&quot;Verificar múltiples contraseñas diferentes - solo una debe coincidir&quot;)
    void matchPassword_multiplesCandidatos_soloUnaCoincide() {
        
<span class="fc" id="L194">        String correctPassword = &quot;CorrectOne123!&quot;;</span>
<span class="fc" id="L195">        String encryptedPassword = passwordService.encryptPassword(correctPassword);</span>
        
<span class="fc" id="L197">        String[] wrongPasswords = {</span>
            &quot;WrongOne123!&quot;,
            &quot;CorrectOne124!&quot;,
            &quot;correctone123!&quot;,
            &quot;CorrectOne123&quot;,
            &quot;CorrectOne123!!&quot;
        };

        
<span class="fc" id="L206">        assertTrue(passwordService.matchPassword(correctPassword, encryptedPassword), </span>
            &quot;La contraseña correcta debe coincidir&quot;);
        
<span class="fc bfc" id="L209" title="All 2 branches covered.">        for (String wrongPassword : wrongPasswords) {</span>
<span class="fc" id="L210">            assertFalse(passwordService.matchPassword(wrongPassword, encryptedPassword), </span>
                &quot;La contraseña '&quot; + wrongPassword + &quot;' no debe coincidir&quot;);
        }
<span class="fc" id="L213">    }</span>

    @Test
    @DisplayName(&quot;Encriptar y verificar contraseña compleja - debe funcionar&quot;)
    void encryptPassword_contraseñaCompleja_debeFuncionar() {
        
<span class="fc" id="L219">        String complexPassword = &quot;C0mpl3x!P@ssw0rd#2024$%&amp;&quot;;</span>

        
<span class="fc" id="L222">        String encrypted = passwordService.encryptPassword(complexPassword);</span>
<span class="fc" id="L223">        boolean matches = passwordService.matchPassword(complexPassword, encrypted);</span>

        
<span class="fc" id="L226">        assertNotNull(encrypted);</span>
<span class="fc" id="L227">        assertTrue(matches, &quot;Debe manejar contraseñas complejas correctamente&quot;);</span>
<span class="fc" id="L228">    }</span>

    @Test
    @DisplayName(&quot;Encriptar misma contraseña 10 veces - todos los hashes deben ser únicos&quot;)
    void encryptPassword_10Veces_todosHashesUnicos() {
        
<span class="fc" id="L234">        String password = &quot;TestPassword123&quot;;</span>
<span class="fc" id="L235">        int iterations = 10;</span>

        
<span class="fc" id="L238">        String[] hashes = new String[iterations];</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">        for (int i = 0; i &lt; iterations; i++) {</span>
<span class="fc" id="L240">            hashes[i] = passwordService.encryptPassword(password);</span>
        }

        
<span class="fc bfc" id="L244" title="All 2 branches covered.">        for (int i = 0; i &lt; iterations; i++) {</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">            for (int j = i + 1; j &lt; iterations; j++) {</span>
<span class="fc" id="L246">                assertNotEquals(hashes[i], hashes[j], </span>
                    &quot;Todos los hashes deben ser únicos debido al salt aleatorio&quot;);
            }
        }

        
<span class="fc bfc" id="L252" title="All 2 branches covered.">        for (String hash : hashes) {</span>
<span class="fc" id="L253">            assertTrue(passwordService.matchPassword(password, hash), </span>
                &quot;Todos los hashes deben verificar correctamente&quot;);
        }
<span class="fc" id="L256">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>